import java.util.*;import java.awt.Color;/** * Classe regroupant toutes les methodes calculatoire liees au deplacement des tetraminos, au score, au niveau, a la supression des lignes... * */public class ControleGrille {	public Color[][] grille;	public Tetraminos tetraminoActuel;	public Tetraminos tetraminoPrecedentePosition;	public Tetraminos tetraminoHold;	public Tetraminos tetraminoSuivant;	GestionTetraminos gestionTetraminos=new GestionTetraminos();	public int score=0;	public boolean perdu=false;	public int niveau=0;	private final int NBCASESLARGEUR=12;	private final int NBCASESLONGUEUR=21;	public ControleGrille() {	}		/**	 * Initialise une grille (tableau 2D de couleur) les cases en noir et les parois grises	 * Initialise les premiers tetraminos	 * */		public void initialiserGrille() {		grille=new Color[NBCASESLONGUEUR][NBCASESLARGEUR];		for(int i = 0 ; i<grille.length ; i++) {			for(int j = 0 ; j<grille[i].length ; j++) {				if(j == 0 || j == grille[i].length-1) {					grille[i][j]=Color.gray;				}else{					grille[i][j]=Color.black;				}			}		}		for(int k=0;k<NBCASESLARGEUR;k++) {			grille[NBCASESLONGUEUR-1][k]=Color.gray;		}		tetraminoHold=gestionTetraminos.TetraminoAleatoire();		tetraminoSuivant=gestionTetraminos.TetraminoAleatoire();		initialiserTetramino();	}		/**	 * Methode initialisant un tetramino en haut de la grille	 * Actualise les deux tetraminos suivants	 * Detecte si la partie est perdue	 * */		public void initialiserTetramino() {		Point[] coordonneesTetraActuel=new Point[4];		for (int i = 0 ; i<4 ; i++) {			int x=tetraminoHold.coordsTetrimino[i].x;			int y=tetraminoHold.coordsTetrimino[i].y;			coordonneesTetraActuel[i]=new Point(x,y);		}		Color couleurTetraActuel=tetraminoHold.couleurTetra;		if(couleurTetraActuel==Color.cyan) {			tetraminoActuel=new Tetraminos(coordonneesTetraActuel,couleurTetraActuel ,new Point(5,2));//Le tetramino bleu part d'une case en dessous pour éviter qu'il depasse de la grille		} else {			tetraminoActuel=new Tetraminos(coordonneesTetraActuel,couleurTetraActuel ,new Point(5,1));		}		Point[] coordonneesTetraHold=tetraminoSuivant.coordsTetrimino;		Color couleurTetraHold=tetraminoSuivant.couleurTetra;		tetraminoHold=new Tetraminos(coordonneesTetraHold,couleurTetraHold);		tetraminoSuivant=gestionTetraminos.TetraminoAleatoire();				//Detecte si la partie est perdue		if(ObjetDessous() == true) {				perdu=true;						}	}		//Detecte s'il y a un objet dessous 	public boolean ObjetDessous() {		int i=0;		boolean t = false;		while(!t && i<tetraminoActuel.coordsTetrimino.length) {			if (grille[tetraminoActuel.origineTetramino.y+tetraminoActuel.coordsTetrimino[i].y+1][tetraminoActuel.origineTetramino.x+tetraminoActuel.coordsTetrimino[i].x]!=Color.black) {				t = true;			}						i++;		}        return t;	}		//Detecte si il y a un objet a droite	public boolean ObjetDroite() {		int i=0;		boolean t = false;		while(!t && i<tetraminoActuel.coordsTetrimino.length) {			if(grille[tetraminoActuel.origineTetramino.y+tetraminoActuel.coordsTetrimino[i].y][tetraminoActuel.origineTetramino.x+tetraminoActuel.coordsTetrimino[i].x+1]!=Color.black) {				t = true;			}						i++;		}        return t;	}		//Detecte si il y a un objet a gauche	public boolean ObjetGauche() {		int i=0;		boolean t = false;		while(!t && i<4) {			if(grille[tetraminoActuel.origineTetramino.y+tetraminoActuel.coordsTetrimino[i].y][tetraminoActuel.origineTetramino.x+tetraminoActuel.coordsTetrimino[i].x-1]!=Color.black) {				t = true;							}						i++;		}        return t;	}		//Fait descendre le tetramino d'une case	public void Descendre() {		if(!ObjetDessous()) {			tetraminoActuel.origineTetramino=new Point(tetraminoActuel.origineTetramino.x,tetraminoActuel.origineTetramino.y+1);		} else {			FixerPiece();		}	}  		//Fixe les tetraminos	public void FixerPiece() {		for(int i = 0 ; i<4 ; i++){			grille[tetraminoActuel.coordsTetrimino[i].y+tetraminoActuel.origineTetramino.y][tetraminoActuel.coordsTetrimino[i].x+tetraminoActuel.origineTetramino.x]=tetraminoActuel.couleurTetra;		}		NettoyerLignes();		initialiserTetramino();	}		//Deplace le tetramino d'une case à droite	public void DeplacementADroite() {		if(!ObjetDroite()) {			tetraminoActuel.origineTetramino=new Point(tetraminoActuel.origineTetramino.x+1,tetraminoActuel.origineTetramino.y);		}	}  		//Deplace le tetramino d'une case à gauche  	public void DeplacementAGauche() {		if(!ObjetGauche()) {			tetraminoActuel.origineTetramino=new Point(tetraminoActuel.origineTetramino.x-1,tetraminoActuel.origineTetramino.y);		}	}  			//Detecte si la rotation est possible	public boolean RotationPossible() {		boolean t=true;		for(int i = 0 ; i < 4 ; i++) {			if(grille[tetraminoActuel.coordsTetrimino[i].x+tetraminoActuel.origineTetramino.y][-tetraminoActuel.coordsTetrimino[i].y+tetraminoActuel.origineTetramino.x]!=Color.BLACK) {				t=false;			}		}		return t;	}		//Fait pivoter de 90° le tetramino autour du point d'origine	public void Rotation() {		if(tetraminoActuel.couleurTetra != Color.yellow && RotationPossible()){			for(int i = 0; i < 4; ++i) {				int a = -tetraminoActuel.coordsTetrimino[i].y;				int b = tetraminoActuel.coordsTetrimino[i].x;				tetraminoActuel.coordsTetrimino[i].x = a;				tetraminoActuel.coordsTetrimino[i].y = b;			}		}	}		/**	 * Retire les lignes completes	 * Ajoute des points au score en fonction du nombre de ligne a supprimer	 **/		public void NettoyerLignes() {		boolean t;		int nbrLigneSup = 0;		for(int j = 19 ; j > 0 ; j--) {			t = false;			for (int i = 1 ; i < 11 ; i++) {				if(grille[j][i] == Color.BLACK) {					t = true;				}			}			if(!t) {				SupprimerLigne(j);				j += 1;				nbrLigneSup += 1;				niveau++;			}		}				switch (nbrLigneSup) {		case 1:			score += 40*((int)(niveau/5)+1);			break;		case 2:			score += 100*((int)(niveau/5)+1);			break;		case 3:			score += 300*((int)(niveau/5)+1);			break;		case 4:			score += 1200*((int)(niveau/5)+1);			break;		}	}	//Supprime les lignes indiquees en paramètre	public void SupprimerLigne(int ligne) {		for(int j = ligne-1 ; j > 0 ; j--) {			for(int i = 1 ; i < 11 ; i++) {				grille[j+1][i] = grille[j][i];			}		}	}				}